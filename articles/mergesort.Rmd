---
title: "Mergesort"
output: github_document
---

```{r, include=FALSE}
library(tidyverse)
library(algovis)
library(ggplot2)
library(gganimate)
```

## Description
Mergesort is a divide-and-conquer sorting technique, where a larger problem is recursively divided and solved at a finer granularity.
The below animation depicts the mergesort algorithm applied to a 25 element numeric vector.
```{r plot-mergesort, fig.align='center', message=FALSE, echo=FALSE}
set.seed(0)
test_vector <- runif(25) * 10
sorting_snapshots <- mergeSortSnapshot(test_vector) %>% rename_all(function(x) {str_extract(x, "[0-9]+")})

anim <- sorting_snapshots %>%
  pivot_longer(everything()) %>% 
  mutate(
    name = as.integer(name)
  ) %>%
  group_by(name) %>% 
  mutate(
    position = row_number()
  ) %>% 
  ggplot() + 
  aes(x = position, y = value) + 
  geom_col() + 
  theme_void() +
  transition_manual(name) +
  ggtitle('Merge Sort - Iteration #{current_frame}')
animate(anim, renderer = gifski_renderer(), fps = 5, end_pause = 5)
```
Note how portions of the vector are sorted, which are subsequently sorted again as part of a larger sub-vector.
The final sorting step occurs when the two halves of the vector are themselves sorted and merged.
This illustrates the recursive nature of the algorithm.


## Implementation

```{cpp}
void mergeSort(NumericVector data, int left_idx, int right_idx)
{
  if (left_idx < right_idx)
  {
    int mid_idx = (left_idx + right_idx) / 2;
    mergeSort(data, left_idx, mid_idx);
    mergeSort(data, mid_idx + 1, right_idx);
    merge(data, left_idx, mid_idx, right_idx);
  }
}

void merge(NumericVector data, int left_idx, int mid_idx, int right_idx)
{
  NumericVector Left = data[Range(left_idx, mid_idx)];
  NumericVector Right = data[Range(mid_idx + 1, right_idx)];

  NumericVector::iterator left_iter = Left.begin();
  NumericVector::iterator right_iter = Right.begin();
  NumericVector::iterator subset_iter = data.begin() + left_idx;

  while (left_iter != Left.end() && right_iter != Right.end())
  {
    if (*left_iter < *right_iter)
    {
      *subset_iter = *left_iter;
      left_iter++;
    }
    else
    {
      *subset_iter = *right_iter;
      right_iter++;
    }
    subset_iter++;
  }

  while (left_iter != Left.end())
  {
    *subset_iter = *left_iter;
    left_iter++;
    subset_iter++;
  }

  while (right_iter != Right.end())
  {
    *subset_iter = *right_iter;
    right_iter++;
    subset_iter++;
  }
}
```
